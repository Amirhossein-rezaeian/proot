./syscall/seccomp.c:	assert(tracee != NULL && tracee->ctx != NULL);
./syscall/seccomp.c:	status = merge_filtered_sysnums(tracee->ctx, &filtered_sysnums, proot_sysnums);
./syscall/seccomp.c:	if (tracee->extensions != NULL) {
./syscall/seccomp.c:		LIST_FOREACH(extension, tracee->extensions, link) {
./syscall/seccomp.c:			status = merge_filtered_sysnums(tracee->ctx, &filtered_sysnums,
./syscall/socket.c:		shorter_host_path = create_temp_name(tracee->ctx, "proot");
./syscall/socket.c:		binding = insort_binding3(tracee, tracee->ctx, shorter_host_path, user_path);
./syscall/socket.c:		talloc_reparent(tracee->ctx, binding, shorter_host_path);
./syscall/exit.c: * the @tracee->pid process area. This function sets the result of
./syscall/exit.c: * this syscall to @tracee->status if an error occured previously
./syscall/exit.c: * during the translation, that is, if @tracee->status is less than 0.
./syscall/exit.c:	if (tracee->status < 0) {
./syscall/exit.c:		poke_reg(tracee, SYSARG_RESULT, (word_t) tracee->status);
./syscall/exit.c:		new_size = strlen(tracee->fs->cwd) + 1;
./syscall/exit.c:		status = write_data(tracee, output, tracee->fs->cwd, new_size);
./syscall/exit.c:		 * "point-of-view" as tracee->fs->cwd (guest).  */
./syscall/exit.c:		comparison = compare_paths(old_path, tracee->fs->cwd);
./syscall/exit.c:		 * "point-of-view" as tracee->fs->cwd (guest).  */
./syscall/exit.c:		if (strlen(tracee->fs->cwd) >= PATH_MAX) {
./syscall/exit.c:		strcpy(old_path, tracee->fs->cwd);
./syscall/exit.c:		tmp = talloc_strdup(tracee->fs, old_path);
./syscall/exit.c:		TALLOC_FREE(tracee->fs->cwd);
./syscall/exit.c:		tracee->fs->cwd = tmp;
./syscall/exit.c:		if (tracee->as_ptracer.waits_in != WAITS_IN_PROOT)
./syscall/chain.c:	if (tracee->chain.syscalls == NULL) {
./syscall/chain.c:		tracee->chain.syscalls = talloc_zero(tracee, struct chained_syscalls);
./syscall/chain.c:		if (tracee->chain.syscalls == NULL)
./syscall/chain.c:		STAILQ_INIT(tracee->chain.syscalls);
./syscall/chain.c:	syscall = talloc_zero(tracee->chain.syscalls, struct chained_syscall);
./syscall/chain.c:		STAILQ_INSERT_HEAD(tracee->chain.syscalls, syscall, link);
./syscall/chain.c:		STAILQ_INSERT_TAIL(tracee->chain.syscalls, syscall, link);
./syscall/chain.c: * @tracee->chain.final_result.  This function returns -errno if an
./syscall/chain.c: * Use/remove the first element of @tracee->chain.syscalls to forge a
./syscall/chain.c:	assert(tracee->chain.syscalls != NULL);
./syscall/chain.c:	if (STAILQ_EMPTY(tracee->chain.syscalls)) {
./syscall/chain.c:		TALLOC_FREE(tracee->chain.syscalls);
./syscall/chain.c:		if (tracee->chain.force_final_result)
./syscall/chain.c:			poke_reg(tracee, SYSARG_RESULT, tracee->chain.final_result);
./syscall/chain.c:		tracee->chain.force_final_result = false;
./syscall/chain.c:		tracee->chain.final_result = 0;
./syscall/chain.c:	tracee->restore_original_regs = false;
./syscall/chain.c:	syscall = STAILQ_FIRST(tracee->chain.syscalls);
./syscall/chain.c:	STAILQ_REMOVE_HEAD(tracee->chain.syscalls, link);
./syscall/chain.c:	if (tracee->_regs[CURRENT].ARM_cpsr & PSR_T_BIT) {
./syscall/chain.c:	tracee->restart_how = PTRACE_SYSCALL;
./syscall/chain.c:	tracee->chain.force_final_result = true;
./syscall/chain.c:	tracee->chain.final_result = forced_result;
./syscall/chain.c:	assert(tracee->chain.sysnum_workaround_state == SYSNUM_WORKAROUND_INACTIVE);
./syscall/chain.c:	tracee->chain.sysnum_workaround_state = SYSNUM_WORKAROUND_PROCESS_FAULTY_CALL;
./syscall/heap.c:	if (tracee->heap->disabled)
./syscall/heap.c:	if (tracee->heap->base == 0) {
./syscall/heap.c:			if (tracee->verbose > 0)
./syscall/heap.c:					"process %d is doing suspicious brk()",	tracee->pid);
./syscall/heap.c:		mappings = tracee->load_info->mappings;
./syscall/heap.c:	if (new_brk_address < tracee->heap->base) {
./syscall/heap.c:	new_heap_size = new_brk_address - tracee->heap->base;
./syscall/heap.c:	old_heap_size = tracee->heap->size;
./syscall/heap.c:	poke_reg(tracee, SYSARG_1 /* old_address */, tracee->heap->base - heap_offset);
./syscall/heap.c:	if (tracee->heap->disabled)
./syscall/heap.c:		poke_reg(tracee, SYSARG_RESULT, tracee->heap->base + tracee->heap->size);
./syscall/heap.c:		tracee->heap->base = result + heap_offset;
./syscall/heap.c:		tracee->heap->size = 0;
./syscall/heap.c:		poke_reg(tracee, SYSARG_RESULT, tracee->heap->base + tracee->heap->size);
./syscall/heap.c:		    || (tracee->heap->base != result + heap_offset)) {
./syscall/heap.c:			poke_reg(tracee, SYSARG_RESULT, tracee->heap->base + tracee->heap->size);
./syscall/heap.c:		tracee->heap->size = peek_reg(tracee, MODIFIED, SYSARG_3) - heap_offset;
./syscall/heap.c:		poke_reg(tracee, SYSARG_RESULT, tracee->heap->base + tracee->heap->size);
./syscall/heap.c:			tracee->heap->disabled = true;
./syscall/enter.c: * @tracee->pid process area. This function sets @tracee->status to
./syscall/enter.c:		tmp = talloc_strdup(tracee->fs, path);
./syscall/enter.c:		TALLOC_FREE(tracee->fs->cwd);
./syscall/enter.c:		tracee->fs->cwd = tmp;
./syscall/enter.c:		talloc_set_name_const(tracee->fs->cwd, "$cwd");
./syscall/syscall.c:	assert(tracee->exe != NULL);
./syscall/syscall.c:		tracee->restore_original_regs = false;
./syscall/syscall.c:		if (tracee->pokedata_workaround_relaunched_syscall) {
./syscall/syscall.c:			tracee->pokedata_workaround_relaunched_syscall = false;
./syscall/syscall.c:			tracee->status = 1;
./syscall/syscall.c:			tracee->restart_how = PTRACE_SYSCALL;
./syscall/syscall.c:		if (tracee->chain.syscalls == NULL) {
./syscall/syscall.c:			if (tracee->chain.sysnum_workaround_state != SYSNUM_WORKAROUND_PROCESS_REPLACED_CALL) {
./syscall/syscall.c:			tracee->restart_how = PTRACE_SYSCALL;
./syscall/syscall.c:			tracee->status = status;
./syscall/syscall.c:			tracee->restart_how = PTRACE_SYSCALL;
./syscall/syscall.c:			tracee->status = 1;
./syscall/syscall.c:			tracee->syscall_void_at_enter_end = true;
./syscall/syscall.c:			tracee->syscall_void_at_enter_end_result = peek_reg(tracee, CURRENT, SYSARG_RESULT);
./syscall/syscall.c:			tracee->syscall_void_at_enter_end = false;
./syscall/syscall.c:		if (tracee->pokedata_workaround_cancelled_syscall) {
./syscall/syscall.c:			tracee->pokedata_workaround_cancelled_syscall = false;
./syscall/syscall.c:				tracee->pokedata_workaround_relaunched_syscall = true;
./syscall/syscall.c:				tracee->restart_how = PTRACE_SYSCALL;
./syscall/syscall.c:				tracee->status = 0;
./syscall/syscall.c:		if (tracee->restart_how == PTRACE_CONT) {
./syscall/syscall.c:			suppressed_syscall_status = tracee->status;
./syscall/syscall.c:			tracee->status = 0;
./syscall/syscall.c:		tracee->restore_original_regs = true;
./syscall/syscall.c:		if (tracee->pokedata_workaround_relaunched_syscall)
./syscall/syscall.c:		if (tracee->chain.syscalls == NULL || tracee->chain.sysnum_workaround_state == SYSNUM_WORKAROUND_PROCESS_REPLACED_CALL) {
./syscall/syscall.c:			tracee->chain.sysnum_workaround_state = SYSNUM_WORKAROUND_INACTIVE;
./syscall/syscall.c:		else if (tracee->chain.sysnum_workaround_state == SYSNUM_WORKAROUND_PROCESS_FAULTY_CALL) {
./syscall/syscall.c:			tracee->chain.sysnum_workaround_state = SYSNUM_WORKAROUND_PROCESS_REPLACED_CALL;
./syscall/syscall.c:		tracee->status = 0;
./syscall/syscall.c:		tracee->pokedata_workaround_cancelled_syscall = false;
./syscall/syscall.c:		if (tracee->chain.syscalls != NULL)
./syscall/syscall.c:	bool override_sysnum = is_enter_stage && tracee->chain.syscalls == NULL;
./syscall/syscall.c:				 * that we can't just make syscall nop, restore tracee->status
./syscall/syscall.c:				tracee->status = suppressed_syscall_status;
./syscall/syscall.c:				tracee->restart_how = PTRACE_SYSCALL;
./ptrace/wait.c:	if (PTRACEE.ptracer == ptracee->parent
./ptrace/wait.c:	result = ptracee->pid;
./ptrace/wait.c:	if (   (PTRACER.wait_pid == -1 || PTRACER.wait_pid == ptracee->pid)
./ptrace/ptrace.h:#define PTRACEE (ptracee->as_ptracee)
./ptrace/ptrace.c:		ptracer = tracee->parent;
./ptrace/ptrace.c:		if (tracee->seccomp == ENABLED)
./ptrace/ptrace.c:			tracee->seccomp = DISABLING;
./ptrace/ptrace.c:		if (ptracee != NULL && ptracee->exe == NULL && !warned) {
./ptrace/ptrace.c:		ptracee->restart_how = PTRACE_SINGLESTEP;
./ptrace/ptrace.c:		ptracee->restart_how = PTRACE_SINGLEBLOCK;
./ptrace/ptrace.c:			tmp = (word_t) ptrace(PTRACE_PEEKDATA, ptracee->pid, address, NULL);
./execve/auxv.c: * @tracee->ctx).
./execve/auxv.c:	vectors = talloc_array(tracee->ctx, ElfAuxVector, 1);
./execve/aoxp.c:	*array_ = talloc_zero(tracee->ctx, ArrayOfXPointers);
./execve/aoxp.c:	pod_array = talloc_zero_size(tracee->ctx, array->length * sizeof_word(tracee));
./execve/aoxp.c:	local = talloc_zero_array(tracee->ctx, struct iovec, array->length + 1);
./execve/exit.c: * Bind content of @vectors over /proc/{@ptracee->pid}/auxv.  This
./execve/exit.c:	guest_path = talloc_asprintf(ptracee->ctx, "/proc/%d/auxv", ptracee->pid);
./execve/exit.c:	host_path = create_temp_file(ptracee->ctx, "auxv");
./execve/exit.c:	binding = insort_binding3(ptracee, ptracee->life_context, host_path, guest_path);
./execve/exit.c:	talloc_reparent(ptracee->ctx, binding, host_path);
./execve/exit.c: * Convert @tracee->load_info into a load script, then transfer this
./execve/exit.c:	needs_executable_stack = (tracee->load_info->needs_executable_stack
./execve/exit.c:				|| (   tracee->load_info->interp != NULL
./execve/exit.c:				    && tracee->load_info->interp->needs_executable_stack));
./execve/exit.c:	string1_size = strlen(tracee->load_info->user_path) + 1;
./execve/exit.c:	string2_size = (tracee->load_info->interp == NULL ? 0
./execve/exit.c:			: strlen(tracee->load_info->interp->user_path) + 1);
./execve/exit.c:	string3_size = (tracee->load_info->raw_path == tracee->load_info->user_path ? 0
./execve/exit.c:			: strlen(tracee->load_info->raw_path) + 1);
./execve/exit.c:			* talloc_array_length(tracee->load_info->mappings))
./execve/exit.c:		+ (tracee->load_info->interp == NULL ? 0
./execve/exit.c:				* talloc_array_length(tracee->load_info->interp->mappings)))
./execve/exit.c:	buffer = talloc_zero_size(tracee->ctx, buffer_size);
./execve/exit.c:	cursor = transcript_mappings(cursor, tracee->load_info->mappings);
./execve/exit.c:	if (tracee->load_info->interp != NULL) {
./execve/exit.c:		cursor = transcript_mappings(cursor, tracee->load_info->interp->mappings);
./execve/exit.c:		entry_point = ELF_FIELD(tracee->load_info->interp->elf_header, entry);
./execve/exit.c:		entry_point = ELF_FIELD(tracee->load_info->elf_header, entry);
./execve/exit.c:	if (tracee->as_ptracee.ptracer != NULL)
./execve/exit.c:	statement->start.at_phent = ELF_FIELD(tracee->load_info->elf_header, phentsize);
./execve/exit.c:	statement->start.at_phnum = ELF_FIELD(tracee->load_info->elf_header, phnum);
./execve/exit.c:	statement->start.at_entry = ELF_FIELD(tracee->load_info->elf_header, entry);
./execve/exit.c:	statement->start.at_phdr  = ELF_FIELD(tracee->load_info->elf_header, phoff)
./execve/exit.c:				  + tracee->load_info->mappings[0].addr;
./execve/exit.c:	memcpy(cursor, tracee->load_info->user_path, string1_size);
./execve/exit.c:		memcpy(cursor, tracee->load_info->interp->user_path, string2_size);
./execve/exit.c:		memcpy(cursor, tracee->load_info->raw_path, string3_size);
./execve/exit.c:	tracee->_regs_were_changed = true;
./execve/exit.c:		tracee->_regs[CURRENT].ARM_cpsr &= ~PSR_T_BIT;
./execve/exit.c:		tracee->_regs_were_changed = true;
./execve/exit.c:		if ((tracee->as_ptracee.options & PTRACE_O_TRACEEXEC) == 0)
./execve/exit.c:			kill(tracee->pid, SIGTRAP);
./execve/exit.c:	if (tracee->new_exe != NULL) {
./execve/exit.c:		(void) talloc_unlink(tracee, tracee->exe);
./execve/exit.c:		tracee->exe = talloc_reference(tracee, tracee->new_exe);
./execve/exit.c:		talloc_set_name_const(tracee->exe, "$exe");
./execve/exit.c:	if (talloc_reference_count(tracee->heap) >= 1) {
./execve/exit.c:		talloc_unlink(tracee, tracee->heap);
./execve/exit.c:		tracee->heap = talloc_zero(tracee, Heap);
./execve/exit.c:		if (tracee->heap == NULL)
./execve/exit.c:		bzero(tracee->heap, sizeof(Heap));
./execve/shebang.c:		old_user_path = talloc_strdup(tracee->ctx, user_path);
./execve/elf.c:	if (force_foreign > 0 || !tracee->qemu)
./execve/ldso.c:		if (   tracee->host_ldso_paths != NULL
./execve/ldso.c:		    && tracee->guest_ldso_paths != NULL
./execve/ldso.c:		    && strcmp(env, tracee->host_ldso_paths) == 0)
./execve/ldso.c:			env = (char *) tracee->guest_ldso_paths;
./execve/ldso.c:		tmp = talloc_realloc(tracee->ctx, paths, char, size);
./execve/ldso.c:		*xpaths = talloc_array(tracee->ctx, char, length + 1);
./execve/ldso.c:		tmp = talloc_realloc(tracee->ctx, *xpaths, char, length + 1);
./execve/ldso.c:	else if (tracee->guest_ldso_paths == NULL) {
./execve/ldso.c:			tracee->guest_ldso_paths = talloc_strdup(tracee, env);
./execve/ldso.c:	if (tracee->host_ldso_paths == NULL)
./execve/ldso.c:		tracee->host_ldso_paths = talloc_strdup(tracee, host_ldso_paths);
./execve/enter.c:	user_path = talloc_size(tracee->ctx, P(filesz) + 1);
./execve/enter.c:	if (tracee->qemu != NULL && user_path[0] == '/') {
./execve/enter.c:		user_path = talloc_asprintf(tracee->ctx, "%s%s", HOST_ROOTFS, user_path);
./execve/enter.c:	if (IS_POSITION_INDENPENDANT(tracee->load_info->elf_header)
./execve/enter.c:	    && tracee->load_info->mappings[0].addr == 0) {
./execve/enter.c:		if (IS_CLASS32(tracee->load_info->elf_header))
./execve/enter.c:			add_load_base(tracee->load_info, EXEC_PIC_ADDRESS_32);
./execve/enter.c:		add_load_base(tracee->load_info, EXEC_PIC_ADDRESS);
./execve/enter.c:	if (tracee->load_info->interp == NULL)
./execve/enter.c:	if (IS_POSITION_INDENPENDANT(tracee->load_info->interp->elf_header)
./execve/enter.c:	    && tracee->load_info->interp->mappings[0].addr == 0) {
./execve/enter.c:		if (IS_CLASS32(tracee->load_info->elf_header))
./execve/enter.c:			add_load_base(tracee->load_info->interp, INTERP_PIC_ADDRESS_32);
./execve/enter.c:		add_load_base(tracee->load_info->interp, INTERP_PIC_ADDRESS);
./execve/enter.c:		nb_qemu_args = talloc_array_length(tracee->qemu) - 1;
./execve/enter.c:			status = write_xpointee(argv, i, tracee->qemu[i]);
./execve/enter.c:		assert(strlen(tracee->qemu[0]) + strlen(HOST_ROOTFS) < PATH_MAX);
./execve/enter.c:		assert(tracee->qemu[0][0] == '/');
./execve/enter.c:		strcpy(host_path, tracee->qemu[0]);
./execve/enter.c:	if (tracee->verbose >= 2)
./execve/enter.c:	if (IS_CLASS32(tracee->load_info->elf_header)) {
./execve/enter.c:	if (IS_CLASS32(tracee->load_info->elf_header)) {
./execve/enter.c:		tracee->as_ptracee.ignore_loader_syscalls = false;
./execve/enter.c:	 * value of AT_EXECFN and /proc/{@tracee->pid}/comm.  */
./execve/enter.c:	raw_path = talloc_strdup(tracee->ctx, user_path);
./execve/enter.c:	if (status == 0 && tracee->qemu == NULL)
./execve/enter.c:		talloc_unlink(tracee, tracee->new_exe);
./execve/enter.c:		tracee->new_exe = talloc_strdup(tracee, new_exe);
./execve/enter.c:		tracee->new_exe = NULL;
./execve/enter.c:	if (tracee->qemu != NULL) {
./execve/enter.c:	TALLOC_FREE(tracee->load_info);
./execve/enter.c:	tracee->load_info = talloc_zero(tracee, LoadInfo);
./execve/enter.c:	if (tracee->load_info == NULL)
./execve/enter.c:	tracee->load_info->host_path = talloc_strdup(tracee->load_info, host_path);
./execve/enter.c:	if (tracee->load_info->host_path == NULL)
./execve/enter.c:	tracee->load_info->user_path = talloc_strdup(tracee->load_info, user_path);
./execve/enter.c:	if (tracee->load_info->user_path == NULL)
./execve/enter.c:	tracee->load_info->raw_path = (raw_path != NULL
./execve/enter.c:			? talloc_reparent(tracee->ctx, tracee->load_info, raw_path)
./execve/enter.c:			: talloc_reference(tracee->load_info, tracee->load_info->user_path));
./execve/enter.c:	if (tracee->load_info->raw_path == NULL)
./execve/enter.c:	status = extract_load_info(tracee, tracee->load_info);
./execve/enter.c:	if (tracee->load_info->interp != NULL) {
./execve/enter.c:		status = extract_load_info(tracee, tracee->load_info->interp);
./execve/enter.c:		if (tracee->load_info->interp->interp != NULL) {
./execve/enter.c:			TALLOC_FREE(tracee->load_info->interp->interp);
./execve/enter.c:	tracee->as_ptracee.ignore_loader_syscalls = true;
./tracee/seccomp.c:	tracee->restore_original_regs_after_seccomp_event = true;
./tracee/seccomp.c:	tracee->restart_how = PTRACE_SYSCALL;
./tracee/seccomp.c:	if (tracee->_regs[CURRENT].ARM_cpsr & PSR_T_BIT) {
./tracee/seccomp.c:	tracee->_regs[CURRENT].rax = tracee->_regs[CURRENT].orig_rax;
./tracee/seccomp.c:	tracee->_regs[CURRENT].eax = tracee->_regs[CURRENT].orig_eax;
./tracee/seccomp.c:	tracee->status = 0;
./tracee/seccomp.c:	tracee->restore_original_regs = false;
./tracee/seccomp.c:	tracee->_regs[CURRENT].orig_rax = tracee->_regs[CURRENT].rax;
./tracee/seccomp.c:	tracee->_regs[CURRENT].orig_eax = tracee->_regs[CURRENT].eax;
./tracee/seccomp.c:	tracee->status = 0;
./tracee/seccomp.c:	tracee->restore_original_regs = false;
./tracee/seccomp.c:	memcpy(&tracee->_regs[CURRENT], &tracee->_regs[ORIGINAL], sizeof(tracee->_regs[CURRENT]));
./tracee/seccomp.c:	if (tracee->syscall_void_at_enter_end) {
./tracee/seccomp.c:		set_result_after_seccomp(tracee, tracee->syscall_void_at_enter_end_result);
./tracee/seccomp.c:		set_result_after_seccomp(tracee, getpgid(tracee->pid));
./tracee/reg.c:	(*(word_t*) (((uint8_t *) &tracee->_regs[version]) + reg_offset[index]))
./tracee/reg.c:	(*(word_t*) (tracee->_regs[version].cs == 0x23			\
./tracee/reg.c:		? (((uint8_t *) &tracee->_regs[version]) + reg_offset_x86[index]) \
./tracee/reg.c:		: (((uint8_t *) &tracee->_regs[version]) + reg_offset[index])))
./tracee/reg.c:	tracee->_regs_were_changed = true;
./tracee/reg.c:	if (tracee->verbose < verbose_level)
./tracee/reg.c:		tracee->vpid, message,
./tracee/reg.c:		tracee->_regs_were_changed = false;
./tracee/reg.c:	memcpy(&tracee->_regs[version], &tracee->_regs[CURRENT], sizeof(tracee->_regs[CURRENT]));
./tracee/reg.c:	regs.iov_base = &tracee->_regs[CURRENT];
./tracee/reg.c:	regs.iov_len  = sizeof(tracee->_regs[CURRENT]);
./tracee/reg.c:	status = ptrace(PTRACE_GETREGSET, tracee->pid, NT_PRSTATUS, &regs);
./tracee/reg.c:	status = ptrace(PTRACE_GETREGS, tracee->pid, NULL, &tracee->_regs[CURRENT]);
./tracee/reg.c:	if (tracee->_regs_were_changed
./tracee/reg.c:			|| (tracee->restore_original_regs && tracee->restore_original_regs_after_seccomp_event)) {
./tracee/reg.c:		if (tracee->restore_original_regs) {
./tracee/reg.c:			if (tracee->restore_original_regs_after_seccomp_event) {
./tracee/reg.c:				tracee->restore_original_regs_after_seccomp_event = false;
./tracee/reg.c:			status = ptrace(PTRACE_SETREGSET, tracee->pid, NT_ARM_SYSTEM_CALL, &regs);
./tracee/reg.c:		regs.iov_base = &tracee->_regs[CURRENT];
./tracee/reg.c:		regs.iov_len  = sizeof(tracee->_regs[CURRENT]);
./tracee/reg.c:		status = ptrace(PTRACE_SETREGSET, tracee->pid, NT_PRSTATUS, &regs);
./tracee/reg.c:			status = ptrace(PTRACE_SET_SYSCALL, tracee->pid, 0, current_sysnum);
./tracee/reg.c:		status = ptrace(PTRACE_SETREGS, tracee->pid, NULL, &tracee->_regs[CURRENT]);
./tracee/tracee.c:	talloc_report_depth_cb(tracee->life_context, 0, 100, clean_life_span_object, tracee);
./tracee/tracee.c:	ptracer = tracee->as_ptracee.ptracer;
./tracee/tracee.c:	event = tracee->as_ptracee.event4.ptracer.value;
./tracee/tracee.c:	if (tracee->as_ptracee.event4.ptracer.pending
./tracee/tracee.c:			zombie->parent = tracee->parent;
./tracee/tracee.c:			zombie->clone = tracee->clone;
./tracee/tracee.c:			zombie->pid = tracee->pid;
./tracee/tracee.c:	tracee->ctx = talloc_new(tracee);
./tracee/tracee.c:	if (tracee->ctx == NULL)
./tracee/tracee.c:	tracee->fs = talloc_zero(tracee, FileSystemNameSpace);
./tracee/tracee.c:	tracee->heap = talloc_zero(tracee, Heap);
./tracee/tracee.c:	if (tracee->fs == NULL || tracee->heap == NULL)
./tracee/tracee.c:	tracee->pid = pid;
./tracee/tracee.c:	tracee->vpid = next_vpid++;
./tracee/tracee.c:	tracee->life_context = talloc_new(tracee);
./tracee/tracee.c:		if (pid != ptracee->pid && pid != -1)
./tracee/tracee.c:		if (pid != ptracee->pid && pid != -1)
./tracee/tracee.c:		if (ptracee->running)
./tracee/tracee.c:		if (pid == ptracee->pid)
./tracee/tracee.c:	if (current_tracee != NULL && current_tracee->pid == pid)
./tracee/tracee.c:		if (tracee->pid == pid) {
./tracee/tracee.c:			TALLOC_FREE(tracee->ctx);
./tracee/tracee.c:			tracee->ctx = talloc_new(tracee);
./tracee/tracee.c:	tracee->terminated = true;
./tracee/tracee.c:	if (tracee->killall_on_exit) {
./tracee/tracee.c:		next = tracee->link.le_next;
./tracee/tracee.c:		if (tracee->terminated)
./tracee/tracee.c:		kill(tracee->pid, SIGKILL);
./tracee/event.c: * Start @tracee->exe with the given @argv[].  This function
./tracee/event.c:	if (tracee->verbose > 0)
./tracee/event.c:		execvp(tracee->exe, argv[0] != NULL ? argv : default_argv);
./tracee/event.c:		tracee->pid = pid;
./tracee/event.c:			if (ptr == tracee->fs->bindings.pending)
./tracee/event.c:			else if (ptr == tracee->fs->bindings.guest)
./tracee/event.c:			else if (ptr == tracee->fs->bindings.host)
./tracee/event.c:	if (tracee->exe == NULL)
./tracee/event.c:	status = translate_path(tracee, path, AT_FDCWD, tracee->exe, false);
./tracee/event.c:		"%s handles 32-bit programs only", path, tracee->tool_name);
./tracee/event.c:		tracee->running = false;
./tracee/event.c:		if (tracee->as_ptracee.ptracer != NULL) {
./tracee/event.c:	sysexit_necessary = tracee->sysexit_pending
./tracee/event.c:				|| tracee->chain.syscalls != NULL
./tracee/event.c:				|| tracee->restore_original_regs_after_seccomp_event;
./tracee/event.c:	if (tracee->restart_how == 0) {
./tracee/event.c:		if (tracee->seccomp == ENABLED && !sysexit_necessary)
./tracee/event.c:			tracee->restart_how = PTRACE_CONT;
./tracee/event.c:			tracee->restart_how = PTRACE_SYSCALL;
./tracee/event.c:			tracee->vpid, last_exit_status);
./tracee/event.c:		VERBOSE(tracee, (int) (tracee->vpid != 1),
./tracee/event.c:			tracee->vpid, WTERMSIG(tracee_status));
./tracee/event.c:			status = ptrace(PTRACE_SETOPTIONS, tracee->pid, NULL,
./tracee/event.c:				status = ptrace(PTRACE_SETOPTIONS, tracee->pid, NULL,
./tracee/event.c:			if (tracee->exe == NULL) {
./tracee/event.c:				tracee->restart_how = PTRACE_CONT;
./tracee/event.c:			switch (tracee->seccomp) {
./tracee/event.c:					tracee->restart_how = PTRACE_SYSCALL;
./tracee/event.c:					tracee->sysexit_pending = true;
./tracee/event.c:					tracee->restart_how = PTRACE_CONT;
./tracee/event.c:					tracee->sysexit_pending = false;
./tracee/event.c:				if (!tracee->seccomp_already_handled_enter)
./tracee/event.c:						tracee->skip_next_seccomp_signal = (
./tracee/event.c:					if (tracee->chain.suppressed_signal && tracee->chain.syscalls == NULL) {
./tracee/event.c:						signal = tracee->chain.suppressed_signal;
./tracee/event.c:						tracee->chain.suppressed_signal = 0;
./tracee/event.c:						VERBOSE(tracee, 6, "vpid %" PRIu64 ": redelivering suppressed signal %d", tracee->vpid, signal);
./tracee/event.c:					tracee->seccomp_already_handled_enter = false;
./tracee/event.c:					tracee->restart_how = PTRACE_SYSCALL;
./tracee/event.c:				if (tracee->seccomp == DISABLING) {
./tracee/event.c:					tracee->restart_how = PTRACE_SYSCALL;
./tracee/event.c:					tracee->seccomp = DISABLED;
./tracee/event.c:				tracee->seccomp = DISABLED;
./tracee/event.c:					tracee->status = 1;
./tracee/event.c:				tracee->seccomp = ENABLED;
./tracee/event.c:			tracee->skip_next_seccomp_signal = false;
./tracee/event.c:				tracee->restart_how = tracee->last_restart_how;
./tracee/event.c:			if (tracee->seccomp != ENABLED)
./tracee/event.c:			status = ptrace(PTRACE_GETEVENTMSG, tracee->pid, NULL, &flags);
./tracee/event.c:					tracee->restart_how = PTRACE_SYSCALL;
./tracee/event.c:				tracee->restart_how = PTRACE_SYSCALL;
./tracee/event.c:			tracee->restart_how = PTRACE_CONT;
./tracee/event.c:			if (tracee->seccomp == DISABLING)
./tracee/event.c:				tracee->restart_how = PTRACE_SYSCALL;
./tracee/event.c:			if (tracee->restart_how == PTRACE_SYSCALL)
./tracee/event.c:				tracee->seccomp_already_handled_enter = true;
./tracee/event.c:			if (tracee->last_restart_how) {
./tracee/event.c:				tracee->restart_how = tracee->last_restart_how;
./tracee/event.c:			if (tracee->exe == NULL) {
./tracee/event.c:				tracee->sigstop = SIGSTOP_PENDING;
./tracee/event.c:			if (tracee->sigstop == SIGSTOP_IGNORED) {
./tracee/event.c:				tracee->sigstop = SIGSTOP_ALLOWED;
./tracee/event.c:			ptrace(PTRACE_GETSIGINFO, tracee->pid, NULL, &siginfo);
./tracee/event.c:				if (tracee->skip_next_seccomp_signal) {
./tracee/event.c:					tracee->skip_next_seccomp_signal = false;
./tracee/event.c:			if (tracee->chain.syscalls != NULL) {
./tracee/event.c:						tracee->vpid, signal, tracee->chain.suppressed_signal);
./tracee/event.c:				tracee->chain.suppressed_signal = signal;
./tracee/event.c:	tracee->as_ptracee.event4.proot.pending = false;
./tracee/event.c:	if (tracee->as_ptracer.wait_pid != 0 || signal == -1)
./tracee/event.c:	assert(tracee->restart_how != 0);
./tracee/event.c:	status = ptrace(tracee->restart_how, tracee->pid, NULL, signal);
./tracee/event.c:	tracee->last_restart_how = tracee->restart_how;
./tracee/event.c:	tracee->restart_how = 0;
./tracee/event.c:	tracee->running = true;
./tracee/mem.c:		status = ptrace(PTRACE_POKEDATA, tracee->pid, addr, word);
./tracee/mem.c:		struct user_regs_struct orig_regs = tracee->_regs[CURRENT];
./tracee/mem.c:		bool restore_original_regs = tracee->restore_original_regs;
./tracee/mem.c:		ptrace(PTRACE_GETSIGMASK, tracee->pid, sizeof(sigset_t), &orig_sigset);
./tracee/mem.c:		int sigmask_result = ptrace(PTRACE_SETSIGMASK, tracee->pid, sizeof(sigset_t), &modified_sigset);
./tracee/mem.c:		word_t pokedata_workaround_stub_addr = tracee->pokedata_workaround_stub_addr;
./tracee/mem.c:		tracee->_regs_were_changed = true;
./tracee/mem.c:		tracee->restore_original_regs = false;
./tracee/mem.c:			ptrace(PTRACE_CONT, tracee->pid, 0, 0);
./tracee/mem.c:			waitpid(tracee->pid, &wstatus, 0);
./tracee/mem.c:			kill(tracee->pid, SIGSTOP);
./tracee/mem.c:		if (tracee->verbose >= 3)
./tracee/mem.c:		ptrace(PTRACE_SETSIGMASK, tracee->pid, sizeof(sigset_t), &orig_sigset);
./tracee/mem.c:		tracee->_regs[CURRENT] = orig_regs;
./tracee/mem.c:		tracee->_regs_were_changed = true;
./tracee/mem.c:		tracee->pokedata_workaround_cancelled_syscall = true;
./tracee/mem.c:		tracee->restore_original_regs = restore_original_regs;
./tracee/mem.c:	tracee->pokedata_workaround_stub_addr = peek_reg(tracee, CURRENT, INSTR_POINTER) + offset_to_pokedata_workaround;
./tracee/mem.c:	tracee->pokedata_workaround_stub_addr = (word_t)&launcher_pokedata_workaround;
./tracee/mem.c:	status = process_vm_writev(tracee->pid, &local, 1, &remote, 1, 0);
./tracee/mem.c:	word = ptrace(PTRACE_PEEKDATA, tracee->pid, dest + i, NULL);
./tracee/mem.c:	status = process_vm_writev(tracee->pid, src_tracer, src_tracer_count, &remote, 1, 0);
./tracee/mem.c:	status = process_vm_readv(tracee->pid, &local, 1, &remote, 1, 0);
./tracee/mem.c:		word = ptrace(PTRACE_PEEKDATA, tracee->pid, src + i, NULL);
./tracee/mem.c:	word = ptrace(PTRACE_PEEKDATA, tracee->pid, src + i, NULL);
./tracee/mem.c:		status = process_vm_readv(tracee->pid, &local, 1, &remote, 1, 0);
./tracee/mem.c:		word = ptrace(PTRACE_PEEKDATA, tracee->pid, src + i, NULL);
./tracee/mem.c:	word = ptrace(PTRACE_PEEKDATA, tracee->pid, src + i, NULL);
./tracee/mem.c:	status = process_vm_readv(tracee->pid, &local, 1, &remote, 1, 0);
./tracee/mem.c:	result = (word_t) ptrace(PTRACE_PEEKDATA, tracee->pid, address, NULL);
./tracee/mem.c:	status = process_vm_writev(tracee->pid, &local, 1, &remote, 1, 0);
./tracee/mem.c:		tmp = (word_t) ptrace(PTRACE_PEEKDATA, tracee->pid, address, NULL);
./tracee/mem.c:	(void) ptrace(PTRACE_POKEDATA, tracee->pid, address, value);
./tracee/abi.h:	switch (tracee->_regs[ORIGINAL].cs) {
./tracee/abi.h:		if (tracee->_regs[ORIGINAL].ds == 0x2B)
./tracee/abi.h:	switch (tracee->_regs[CURRENT].cs) {
./tracee/abi.h:		if (tracee->_regs[CURRENT].ds == 0x2B)
./extension/hidden_files/hidden_files.c:        int status = readlink_proc_pid_fd(tracee->pid, peek_reg(tracee, ORIGINAL, SYSARG_1), path);
./extension/extension.c:	if (tracee->extensions == NULL) {
./extension/extension.c:		tracee->extensions = talloc_zero(tracee, Extensions);
./extension/extension.c:		if (tracee->extensions == NULL)
./extension/extension.c:	extension = talloc_zero(tracee->extensions, Extension);
./extension/extension.c:	LIST_INSERT_HEAD(tracee->extensions, extension, link);
./extension/extension.c: * Retrieve from @tracee->extensions the extension for the given
./extension/extension.c:	if (tracee->extensions == NULL)
./extension/extension.c:	LIST_FOREACH(extension, tracee->extensions, link) {
./extension/link2symlink/link2symlink.c:				status = readlink_proc_pid_fd(tracee->pid, peek_reg(tracee, MODIFIED, SYSARG_1), original);
./extension/kompat/kompat.c:	argv_envp = talloc_size(tracee->ctx, size);
./extension/fake_id0/stat.c:	snprintf(link_path, sizeof(link_path), "/proc/%d/fd/%d", tracee->pid, (int)peek_reg(tracee, CURRENT, fd_sysarg));
./extension/fake_id0/helper_functions.c:			status = readlink_proc_pid_fd(tracee->pid, peek_reg(tracee, version, fd_sysarg), path);
./extension/fake_id0/chroot.c:	for (binding = CIRCLEQ_FIRST(tracee->fs->bindings.guest);
./extension/fake_id0/chroot.c:	     binding != (void *) tracee->fs->bindings.guest;
./extension/fake_id0/chroot.c:		bool is_guest_root = binding == CIRCLEQ_LAST(tracee->fs->bindings.guest);
./extension/fake_id0/chroot.c:		status = translate_path(tracee, path, AT_FDCWD, tracee->fs->cwd, true);
./extension/fake_id0/chroot.c:		talloc_unlink(tracee, tracee->fs);
./extension/fake_id0/chroot.c:		tracee->fs = talloc_zero(tracee, FileSystemNameSpace);
./extension/fake_id0/chroot.c:			tracee->fs->cwd = talloc_strdup(tracee->fs, "/");
./extension/fake_id0/chroot.c:			tracee->fs->cwd = talloc_strdup(tracee->fs, path);
./extension/fake_id0/shm.c:	tracee->word_store[0] = alloc_mem(tracee, sizeof(struct sockaddr_un));
./extension/fake_id0/shm.c:	tracee->word_store[1] = alloc_mem(tracee, sizeof(int));
./extension/fake_id0/shm.c:	tracee->word_store[2] = alloc_mem(tracee, sizeof(key_t));
./extension/fake_id0/shm.c:	tracee->word_store[3] = alloc_mem(tracee, 1);
./extension/fake_id0/shm.c:	tracee->word_store[4] = alloc_mem(tracee, sizeof(struct iovec));
./extension/fake_id0/shm.c:	tracee->word_store[5] = alloc_mem(tracee, sizeof(ancillary_data_buffer));
./extension/fake_id0/shm.c:	tracee->word_store[6] = alloc_mem(tracee, sizeof(struct msghdr));
./extension/fake_id0/shm.c:		write_data(tracee, tracee->word_store[0], &sockaddr, sizeof(struct sockaddr_un));
./extension/fake_id0/shm.c:		tracee->word_store[8] = result;
./extension/fake_id0/shm.c:		tracee->word_store[9] = (word_t)-1;
./extension/fake_id0/shm.c:		register_chained_syscall(tracee, PR_connect, result, tracee->word_store[0], addrlen, 0, 0, 0);
./extension/fake_id0/shm.c:		write_data(tracee, tracee->word_store[1], &shmid, sizeof(int));
./extension/fake_id0/shm.c:		register_chained_syscall(tracee, PR_sendto, tracee->word_store[8], tracee->word_store[1], sizeof(int), 0, 0, 0);
./extension/fake_id0/shm.c:			register_chained_syscall(tracee, PR_close, tracee->word_store[8], 0, 0, 0, 0, 0);
./extension/fake_id0/shm.c:		register_chained_syscall(tracee, PR_read, tracee->word_store[8], tracee->word_store[2], sizeof(key_t), 0, 0, 0);
./extension/fake_id0/shm.c:			register_chained_syscall(tracee, PR_close, tracee->word_store[8], 0, 0, 0, 0, 0);
./extension/fake_id0/shm.c:		write_data(tracee, tracee->word_store[3], &nothing, 1);
./extension/fake_id0/shm.c:		struct iovec nothing_ptr = { .iov_base = (void *)tracee->word_store[3], .iov_len = 1 };
./extension/fake_id0/shm.c:		write_data(tracee, tracee->word_store[4], &nothing_ptr, sizeof(nothing_ptr));
./extension/fake_id0/shm.c:		write_data(tracee, tracee->word_store[5], &ancillary_data_buffer, sizeof(ancillary_data_buffer));
./extension/fake_id0/shm.c:			.msg_iov = (struct iovec *)tracee->word_store[4],
./extension/fake_id0/shm.c:			.msg_control = (void *)tracee->word_store[5],
./extension/fake_id0/shm.c:		write_data(tracee, tracee->word_store[6], &message_header, sizeof(struct msghdr));
./extension/fake_id0/shm.c:		register_chained_syscall(tracee, PR_recvmsg, tracee->word_store[8], tracee->word_store[6], 0, 0, 0, 0);
./extension/fake_id0/shm.c:			register_chained_syscall(tracee, PR_close, tracee->word_store[8], 0, 0, 0, 0, 0);
./extension/fake_id0/shm.c:		read_data(tracee, &message_header_2, tracee->word_store[6], sizeof(struct msghdr));
./extension/fake_id0/shm.c:		tracee->word_store[9] = ancillary_data_buffer_2.fd[0];
./extension/fake_id0/shm.c:		register_chained_syscall(tracee, PR_close, tracee->word_store[8], 0, 0, 0, 0, 0);
./extension/fake_id0/shm.c:		if ((int)tracee->word_store[9] == -1)
./extension/fake_id0/shm.c:		register_chained_syscall(tracee, mmap_sysnum, (word_t)shmaddr, (word_t)shmem[idx].size, (word_t)(PROT_READ | (shmflg == 0 ? PROT_WRITE : 0)), (word_t)MAP_SHARED, tracee->word_store[9], 0);
./extension/fake_id0/fake_id0.c:	node = talloc_zero(tracee->ctx, ModifiedNode);
./extension/fake_id0/fake_id0.c:	RegVersion stage = (tracee->restore_original_regs_after_seccomp_event) ? ORIGINAL_SECCOMP_REWRITE : ORIGINAL;
./extension/fake_id0/fake_id0.c:	status = stat(tracee->load_info->host_path, &mode);
./extension/extension.h:	if (tracee->extensions == NULL)
./extension/extension.h:	LIST_FOREACH(extension, tracee->extensions, link) {
./path/path.c:		if (strlen(tracee->fs->cwd) >= PATH_MAX)
./path/path.c:		strcpy(guest_path, tracee->fs->cwd);
./path/path.c: * Copy in @result the equivalent of "@tracee->root + canon(@dir_fd +
./path/path.c:		/* /proc/@tracee->pid/fd/@dir_fd -> result.  */
./path/path.c:		status = readlink_proc_pid_fd(tracee->pid, dir_fd, result);
./path/path.c:		tracee != NULL ? tracee->vpid : 0, result, user_path);
./path/path.c:		tracee != NULL ? tracee->vpid : 0, result);
./path/path.c:	status = snprintf(proc_fd, sizeof(proc_fd), "/proc/%d/fd", tracee->pid);
./path/path.c:		tracee->pid, path, fd);
./path/canon.c:	if (tracee->glue_type == 0) {
./path/canon.c:	if (status < 0 && tracee->glue_type != 0) {
./path/canon.c: * @user_path regarding to @tracee->root.  The path to canonicalize
./path/binding.c:	if (tracee->fs->bindings.guest == NULL)
./path/binding.c:	if (tracee == NULL || tracee->fs == NULL)
./path/binding.c:	if (tracee->fs->bindings.guest == NULL) {
./path/binding.c:		if (tracee->fs->bindings.pending == NULL
./path/binding.c:		    || CIRCLEQ_EMPTY(tracee->fs->bindings.pending))
./path/binding.c:		binding = CIRCLEQ_LAST(tracee->fs->bindings.pending);
./path/binding.c:	assert(!CIRCLEQ_EMPTY(tracee->fs->bindings.guest));
./path/binding.c:	binding = CIRCLEQ_LAST(tracee->fs->bindings.guest);
./path/binding.c:			if (tracee->verbose > 0 && getenv("PROOT_IGNORE_MISSING_BINDINGS") == NULL) {
./path/binding.c:	if (bindings == tracee->fs->bindings.pending)
./path/binding.c:	else if (bindings == tracee->fs->bindings.guest)
./path/binding.c:	else if (bindings == tracee->fs->bindings.host)
./path/binding.c: * @tracee->fs->bindings.pending.  This function complains about
./path/binding.c:	if (tracee->fs->bindings.pending == NULL) {
./path/binding.c:		tracee->fs->bindings.pending = talloc_zero(tracee->fs, Bindings);
./path/binding.c:		if (tracee->fs->bindings.pending == NULL)
./path/binding.c:		CIRCLEQ_INIT(tracee->fs->bindings.pending);
./path/binding.c:		talloc_set_destructor(tracee->fs->bindings.pending, remove_bindings);
./path/binding.c:	binding = talloc_zero(tracee->ctx, Binding);
./path/binding.c:	status = realpath2(tracee->reconf.tracee, binding->host.path, host, true);
./path/binding.c:		status = getcwd2(tracee->reconf.tracee, base);
./path/binding.c: * @tracee->fs->bindings.guest and @tracee->fs->bindings.host.  This
./path/binding.c:		tracee->glue_type = (status < 0 || S_ISBLK(statl.st_mode) || S_ISCHR(statl.st_mode)
./path/binding.c:		tracee->glue_type = 0;
./path/binding.c:	if (tracee->reconf.tracee == NULL)
./path/binding.c:	status = detranslate_path(tracee->reconf.tracee, path, NULL);
./path/binding.c:	CIRCLEQ_FOREACH_(tracee->reconf.tracee, old_binding, GUEST) {
./path/binding.c:		induced_binding = talloc_zero(tracee->ctx, Binding);
./path/binding.c: * Allocate @tracee->fs->bindings.guest and
./path/binding.c: * @tracee->fs->bindings.host, then call initialize_binding() on each
./path/binding.c: * binding listed in @tracee->fs->bindings.pending.
./path/binding.c:	assert(tracee->fs->bindings.pending != NULL);
./path/binding.c:	assert(tracee->fs->bindings.guest == NULL);
./path/binding.c:	assert(tracee->fs->bindings.host == NULL);
./path/binding.c:	/* Allocate @tracee->fs->bindings.guest and
./path/binding.c:	 * @tracee->fs->bindings.host.  */
./path/binding.c:	tracee->fs->bindings.guest = talloc_zero(tracee->fs, Bindings);
./path/binding.c:	tracee->fs->bindings.host  = talloc_zero(tracee->fs, Bindings);
./path/binding.c:	if (tracee->fs->bindings.guest == NULL || tracee->fs->bindings.host == NULL) {
./path/binding.c:		TALLOC_FREE(tracee->fs->bindings.guest);
./path/binding.c:		TALLOC_FREE(tracee->fs->bindings.host);
./path/binding.c:	CIRCLEQ_INIT(tracee->fs->bindings.guest);
./path/binding.c:	CIRCLEQ_INIT(tracee->fs->bindings.host);
./path/binding.c:	talloc_set_destructor(tracee->fs->bindings.guest, remove_bindings);
./path/binding.c:	talloc_set_destructor(tracee->fs->bindings.host, remove_bindings);
./path/binding.c:	binding = CIRCLEQ_LAST(tracee->fs->bindings.pending);
./path/binding.c:	while (binding != (void *) tracee->fs->bindings.pending) {
./path/binding.c:		 * tracee->fs->bindings.guest/host.  */
./path/binding.c:	TALLOC_FREE(tracee->fs->bindings.pending);
./path/binding.c:	if (tracee->verbose > 0)
./path/glue.c:	assert(tracee->glue_type != 0);
./path/glue.c:	if (tracee->glue == NULL) {
./path/glue.c:		tracee->glue = create_temp_directory(NULL, tracee->tool_name);
./path/glue.c:		if (tracee->glue == NULL) {
./path/glue.c:		talloc_set_name_const(tracee->glue, "$glue");
./path/glue.c:	comparison = compare_paths(tracee->glue, host_path);
./path/glue.c:		type = tracee->glue_type;
./path/glue.c:	 * tracee->glue.  */
./path/glue.c:	if (   strnlen(tracee->glue, PATH_MAX) >= PATH_MAX
./path/glue.c:	binding = insort_binding3(tracee, tracee->glue, tracee->glue, guest_path);
./path/proc.c:		status = snprintf(result, PATH_MAX, "/proc/%d", tracee->pid);
./path/proc.c:		 * of tracee->???.  */
./path/proc.c:		SUBSTITUTE(exe, known_tracee->exe);
./path/proc.c:		SUBSTITUTE(cwd, known_tracee->fs->cwd);
./cli/note.c:		verbose_level = tracee->verbose;
./cli/note.c:		tool_name     = tracee->tool_name;
./cli/proot.c:	host = talloc_strdup(tracee->ctx, value);
./cli/proot.c:	tracee->qemu = talloc_zero_array(tracee, char *, nb_args + 1);
./cli/proot.c:	if (tracee->qemu == NULL)
./cli/proot.c:	talloc_set_name_const(tracee->qemu, "@qemu");
./cli/proot.c:		tracee->qemu[i] = talloc_strndup(tracee->qemu, start, end - start);
./cli/proot.c:		if (tracee->qemu[i] == NULL)
./cli/proot.c:	tracee->fs->cwd = talloc_strdup(tracee->fs, value);
./cli/proot.c:	if (tracee->fs->cwd == NULL)
./cli/proot.c:	talloc_set_name_const(tracee->fs->cwd, "$cwd");
./cli/proot.c:	tracee->killall_on_exit = true;
./cli/proot.c:	status = parse_integer_option(tracee, &tracee->verbose, value, "-v");
./cli/proot.c:	global_verbose_level = tracee->verbose;
./cli/proot.c:			? expand_front_variable(tracee->ctx, bindings[i])
./cli/proot.c: * Initialize @tracee->qemu.
./cli/proot.c:	if (tracee->qemu == NULL)
./cli/proot.c:	/* Resolve the full guest path to tracee->qemu[0].  */
./cli/proot.c:	status = which(tracee->reconf.tracee, tracee->reconf.paths, path, tracee->qemu[0]);
./cli/proot.c:	/* Actually tracee->qemu[0] has to be a host path from the tracee's
./cli/proot.c:	if (tracee->reconf.tracee != NULL) {
./cli/proot.c:		status = detranslate_path(tracee->reconf.tracee, path, NULL);
./cli/proot.c:	tracee->qemu[0] = talloc_strdup(tracee->qemu, path);
./cli/proot.c:	if (tracee->qemu[0] == NULL)
./cli/proot.c:	if (tracee->fs->cwd == NULL) {
./cli/note.h:		if (tracee == NULL || tracee->verbose >= (level))	\
./cli/cli.c:	if (tracee->verbose <= 0)
./cli/cli.c:	if (tracee->qemu)
./cli/cli.c:	if (tracee->glue)
./cli/cli.c:		note(tracee, INFO, USER, "glue rootfs = %s", tracee->glue);
./cli/cli.c:	note(tracee, INFO, USER, "exe = %s", tracee->exe);
./cli/cli.c:	print_argv(tracee, "qemu", tracee->qemu);
./cli/cli.c:	note(tracee, INFO, USER, "initial cwd = %s", tracee->fs->cwd);
./cli/cli.c:	note(tracee, INFO, USER, "verbose level = %d", tracee->verbose);
./cli/cli.c:	if (tracee->fs->cwd[0] != '/') {
./cli/cli.c:		status = getcwd2(tracee->reconf.tracee, path);
./cli/cli.c:	 * if tracee->fs->cwd does not exist or if it is not a
./cli/cli.c:	status = join_paths(3, path2, path, tracee->fs->cwd, ".");
./cli/cli.c:	TALLOC_FREE(tracee->fs->cwd);
./cli/cli.c:	tracee->fs->cwd = talloc_strdup(tracee->fs, path);
./cli/cli.c:	if (tracee->fs->cwd == NULL)
./cli/cli.c:	talloc_set_name_const(tracee->fs->cwd, "$cwd");
./cli/cli.c: * Initialize @tracee->exe from @exe, i.e. canonicalize it from a
./cli/cli.c:	status = which(tracee, tracee->reconf.paths, path, exe ?: "/bin/sh");
./cli/cli.c:	tracee->exe = talloc_strdup(tracee, path);
./cli/cli.c:	if (tracee->exe == NULL)
./cli/cli.c:	talloc_set_name_const(tracee->exe, "$exe");
./cli/cli.c:		cli = get_proot_cli(tracee->ctx);
./cli/cli.c:	tracee->tool_name = cli->name;
./cli/cli.c:	 * user (tracee->bindings.user) can be canonicalized.  */
./cli/cli.c:	/* Bindings are now installed (tracee->bindings.guest &
./cli/cli.c:	 * tracee->bindings.host): the current working directory can
./cli/cli.c:	 * directory is canonicalized: resolve path to @tracee->exe
./cli/cli.c:	 * and configure @tracee->cmdline.  */
./cli/cli.c:	tracee->pid = getpid();
./cli/cli.c:			tracee->verbose = strtol(verbose_env, NULL, 10);
./cli/cli.c:			global_verbose_level = tracee->verbose;
./cli/cli.c:		print_execve_help(tracee, tracee->exe, status);
